
Win32APIはDLLで提供される

ウィンドウメッセージ とは、Windowsシステム、もしくはユーザーが発生させたイベントをアプリケーションに伝えるためのものです。
メッセージが送られてきたらそれに対して処理を行なうことをメッセージ駆動方式あるいはイベント駆動方式、イベントドリブンなどと呼んだりもします。

仮想アドレスの状態
・フリー状態
・予約状態（データを書き込むときにコミットされる。データを読み出そうとするとプログラムが終了する）
・コミット状態（実際に物理アドレスに割り当てられた状態）

予約状態がある理由
・後から他の目的でメモリが必要となり、そのための領域を確保したとしても、すでに予約されている部分の領域は使われない。
・予約されているだけでコミットされていない領域は、物理ストレージ（RAMやページングファイル）を消費していない。

アプリケーションは専用の関数（プログラムコード）を持っていて、Windowsはメッセージを送るときにこの関数を呼び出す、という手段をとります。
この関数は、ウィンドウプロシージャ (window procedure) と呼ばれています。


# アドレス空間の割り当て
32ビットWindowsでは4Gバイトの仮想アドレス空間が割り当てられると言いましたが、
そのうちの上位2Gバイト（アドレス 0x80000000～0xFFFFFFFF）はWindowsのシステム（カーネル）用に予約されているために、
アプリケーションのプロセス側からアクセスすることはできません。したがって、プロセスは下位2Gバイトの領域を使用することになります。
さらに、Windowsはこの2Gバイトの領域（アドレス 0x00000000 ～ 0x7FFFFFFF）のうち、先頭および末尾のいくらかの領域も予約しています。
どのくらいの領域が予約されているのかは、Windowsカーネルが 9x カーネルか NT カーネルかによって異なります。
プロセスが起動されているとき、仮想アドレス内には実行ファイル（EXE）、システムDLL、アプリケーションDLLのからロードされたプログラムコード、
およびプロセス内で使われている各データのブロックが配置されています。プログラムはここにロードされたコードに沿って実行されていくのです。

# DLLを使う
* 「#pragma」を使ってライブラリファイルを検索リストに追加。
* 関数の宣言が入ったヘッダーファイルをインクルード。
* で、使う。

~~~

			ragma comment(lib, "winmm.lib")
			#include <mmsystem.h>

			::sndPlaySound( "Test.wav", SND_ASYNC | SND_NODEFAULT );	//音発生！
~~~

## ライブラリファイルとは
「ライブラリファイル」は、ＤＬＬの作成時に一緒に作製されるファイルです。

エクスポートされた関数・クラスとＤＬＬファイル名が、ライブラリファイルに書き込まれます。

## リンカがDLLをリンクするまで
1. 「このオブジェクトファイルが使ってる関数はどのオブジェクトファイルにあるのかなー」と調べます。その中から見つからないと、「ぐがっ、てことはＤＬＬかぁ！？」
2. 「プロジェクト」－「設定」ダイアログの「リンク」ページ・「一般」カテゴリ・「オブジェクト／ライブラリモジュール」で設定されたライブラリファイルからDLLファイル。
または、#pragma comment(lib, "***")の形式でコードに書かれたファイルを探す。
3. 関数が見つかったら「この関数はこのＤＬＬにあるよ」と書き込んで、終了します。

## 実行時、実行ファイルがDLLファイルを探す手順
1. 実行ファイルのあるフォルダ
2. カレントフォルダ
3. システムフォルダ
4. ウィンドウズフォルダ

## DLLのロード※一般的にロードではなくリンクなのだが、混乱をさけるためロードと書く
* 実行時ロード
* 実行中ロード

### 実行時ロード（暗黙ロード）
アプリケーションが実行されたときDLLをロードする
ライブラリファイルさえあれば、コンパイラが自動的に「ロードの機能」を組み込んでくれます。

### 実行中ロード
	typedef BOOL (sndPlaySound)( LPCSTR, UINT );

	//	typedef 戻り値の型 (関数名)( 引数の型 );	//とゆー書式。

	HINSTANCE	hInst;
	sndPlaySound	*pfnDllFunc;

	hInst = ::LoadLibrary( "winmm" );	//DLLを読み込みます。
	if( hInst == NULL )
	{
		MessageBox( "ＤＬＬをロードできませんでした。" );
		return;
	}

	pfnDllFunc = (sndPlaySound *)::GetProcAddress( hInst, "sndPlaySoundA" );	//関数のアドレスを取得します。
	if( pfnDllFunc == NULL )
	{
		MessageBox( "関数を取得できませんでした。" );
		::FreeLibrary( hInst );       //DLLを解放します。
		return;
	}

	pfnDllFunc( "Test.wav", 0x0001 | 0x0002 );	//音発生！

	::FreeLibrary( hInst ); 

# DLLを作る

# ＭＦＣを使ったＤＬＬには、ふたつのタイプがあります。
* 拡張 DLL
* レギュラーDLL

## 拡張 DLL(MFC の共有 DLL 使用)
拡張 DLLは、使用するＥｘｅやＤＬＬもＭＦＣを使う時にのみ使うことができます。

## レギュラーDLL(MFC の共有 DLL 使用)
レギュラーDLLは、内部的にＭＦＣそのものを持っているため、ＤＬＬを使用するＥｘｅやＤＬＬがＭＦＣを使わなくても使用できます。

## 拡張 DLL(MFC の共有 DLL 使用)で作成されるもの
* StdAfx.h
* リソースファイル
* プロジェクト名.cpp
	* DllMain()
* プロジェクト名.def

## DllMain()
普通のＥｘｅファイルを作製するとき、必ずWinMain()という関数を作製します。ウィンドウズはＥｘｅファイルの中からこの関数を探しだし、呼び出すことでアプリケーションが始動します。

このWinMain()のＤＬＬ版がDllMain()です。WinMain()と同様、ＳＤＫにちゃんと書かれているのでどういう関数なのか知りたい場合にはそちらを見てください（ただしＳＤＫでの名前はDllEntryPoint()です）。

基本的に、この関数は「あればいい」だけで、プログラマー側で手を加えることは少ないでしょう。



## 装飾名
C および C++ プログラム内の関数、データ、オブジェクトは、内部ではそれぞれの装飾名で表されます。

装飾名により、呼び出し規約、型、関数のパラメーター、およびその他の情報が決まります。

装飾名は、リンカーが実行可能ファイルをリンクするとき、正しい関数やオブジェクトを見つけるために役立ちます。

装飾名の名前付け規則は、Visual C++ のさまざまなバージョンごとに異なるため、ファイルと正しくリンクするには、C および C++ の DLL とライブラリを、同じコンパイラツールセット、フラグ、およびターゲットアーキテクチャを使用してコンパイルする必要があります。

## 修飾子
http://docwiki.embarcadero.com/RADStudio/Seattle/ja/%E9%96%A2%E6%95%B0%E4%BF%AE%E9%A3%BE%E5%AD%90

「修飾子」をつけるとで、コンパイル時のメモリ割り当てなどを変えることができます(const,volatailなど)

デフォルトは__cdeclで、特に指定されていない関数は、常にこの
タイプの装飾名に変換されます

ＳＤＫの取り決めで、ＤＬＬからエクスポートされる関数は、__stdcallのタイプの装飾名でなければならないとされています。
ＤＬＬとＥｘｅ、違うファイルが関数を呼び出すのですから、関数のタイプも決めておかなければならないというわけです。

WINAPI、AFXAPIはどちらも__stdcallとして定義されています。

## 関数をエクスポートさせる方法
* 定義ファイル(.def)を使う方法
* __declaspec()を使う方法

### 定義ファイル(.def)を使う方法

